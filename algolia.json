[
  {
    "objectID": "6f4f16226fdd0c422db25b75512033981b2f6d18",
    "permalink": "/post/note-of-vercel-edge-function/",
    "title": "Vercel Serverless笔记","content": "\r1 环境准备\r\u0026#x31;\u0026#xfe0f;\u0026#x20e3;nodejs\nhttps://nodejs.org/\n\u0026#x32;\u0026#xfe0f;\u0026#x20e3;注册Vercel\nhttps://vercel.com/\n\u0026#x33;\u0026#xfe0f;\u0026#x20e3;Vercel CLI\nnpm i -g vercel \u0026#x34;\u0026#xfe0f;\u0026#x20e3;命令行登录vercel\nvercel login 2 Quick Start\r云函数 (Cloud Functions)：在 Vercel 平台上，这通常被称为 Serverless Functions (无服务器函数)。\nVercel 的核心理念是约定优于配置。你不需要复杂的配置文件，只需要将代码放在正确的目录下，Vercel 就会自动将其部署为 Serverless Function。\n核心理念约定优于配置的加持下，编码的核心便是：使用 api/ 目录\n创建项目: 你的项目可以是一个 Next.js 应用，也可以是一个静态网站，甚至是空项目。 创建 api 目录: 在你的项目根目录下，创建一个名为 api 的文件夹。 编写函数代码: 在 api 目录下创建一个 JavaScript 或 TypeScript 文件。文件名将成为 API 的路径。 \u0026#x31;\u0026#xfe0f;\u0026#x20e3;新建空项目first-serverless \u0026#x27a1;\u0026#xfe0f; 项目根目录下新建文件夹api \u0026#x27a1;\u0026#xfe0f; New hello.js\n// 标准 Nodejs HTTP 处理函数 export default function handler(request, response) { const { name } = request.query; response.status(200).json({ message: `Hello, ${name || \u0026#39;World\u0026#39;}! This function is running on the Vercel cloud.`, }); } \u0026#x32;\u0026#xfe0f;\u0026#x20e3;部署\nvercel --prod 执行命令后：\nVercel 会自动检测到 api/hello.js 文件。 它会将这个文件打包成一个独立的 Serverless Function。 它会为你生成一个可访问的 URL 端点：https://\u0026lt;你的域名\u0026gt;.vercel.app/api/hello。 当你访问 .../api/hello 时，这个函数就会在云端被触发执行，例如.../api/hello、.../api/hello?name=anby。 \u0026#x1f6a9;部署成功后得到一个域名，国内访问需要绑定自己的域名，加上后缀api/hello，成功，Congratulations​!\u0026#x1f389;\n","date": "2025-08-01 21:00:00",
    "updated": "2025-07-21 21:00:00"
  }, 
  {
    "objectID": "2debed60e09224a146acc280d3847be6df4ad974",
    "permalink": "/post/what-is-cloud-function/",
    "title": "什么是云函数","content": "\r什么是云函数？\r云函数（Cloud Function），也称为无服务器计算（Serverless Computing）或函数即服务（Function-as-a-Service, FaaS），是一种事件驱动的计算服务。它允许您编写和运行代码，而无需管理自己的服务器。\n核心思想\r云函数的核心思想是 “只在需要时运行”。您只需上传您的代码（一个函数），云服务提供商会负责处理其他所有事情，包括：\n服务器管理：您不需要购买、配置或维护任何物理或虚拟服务器。 自动扩缩容：当函数被调用时，云平台会自动分配计算资源来运行它。如果有很多并发请求，平台会自动扩展以处理负载。当没有请求时，不会有任何资源在运行，因此您也无需付费。 事件驱动：函数通常由特定事件触发，例如： HTTP 请求（API 网关） 文件上传到对象存储（如 AWS S3, 阿里云 OSS） 数据库中的数据发生变化 消息队列中的新消息 定时任务（Cron Job） 主要优势\r降低成本：您只需为代码实际运行的时间付费，精确到毫秒。当代码不运行时，不产生任何费用。这对于流量不稳定的应用来说尤其划算。 简化运维：开发者可以专注于编写核心业务逻辑，而无需担心服务器的配置、补丁、安全和扩展性问题。 高可用性和弹性：云服务提供商通常会在多个可用区运行您的函数，确保高可用性。同时，根据请求量自动伸缩，轻松应对流量高峰。 快速开发和部署：您可以快速地将单个函数部署到云端，并将其集成到现有应用中，大大缩短了开发周期。 常见用例\rWeb API 和后端服务：为移动应用或 Web 应用提供 RESTful API。 数据处理：当新数据（如图片、视频、日志文件）上传到存储服务时，自动触发函数进行处理、转换或分析。 实时消息和通知：处理来自物联网设备的数据流，或在特定事件发生时发送实时通知。 定时任务：执行定期的清理工作、数据备份或报告生成。 胶水代码：将不同的云服务或第三方 API 连接在一起，形成一个完整的工作流。 主流云函数平台\rAWS Lambda：亚马逊推出的业界领先的无服务器计算平台。 Azure Functions：微软 Azure 提供的云函数服务。 Google Cloud Functions：谷歌云的事件驱动计算服务。 阿里云函数计算 (FC)：阿里巴巴集团提供的无服务器计算服务。 腾讯云云函数 (SCF)： …","date": "2025-08-01 16:55:00",
    "updated": "2025-08-01 16:55:00"
  }, 
  {
    "objectID": "da9267a3b42970b72e9a0b1909ff34accefd2f0f",
    "permalink": "/post/tech-docs/",
    "title": "常用技术文档合集","content": "\rNodejs Api\rhttps://nodejs.org/docs/latest/api/\rVite\rhttps://cn.vitejs.dev/guide/\rVue\rhttps://cn.vuejs.org/guide/\rRedis Commands\rhttps://redis.io/docs/latest/commands/\r","date": "2025-08-01 12:00:00",
    "updated": "2025-08-01 12:00:00"
  }, 
  {
    "objectID": "67162b4878ac71fe5dfad5d3b584dffb40612716",
    "permalink": "/post/webhook-github/",
    "title": "Webhook实现Github自动推送到Linux自动部署","content": "\u0026amp;#x2600;\u0026amp;#xfe0f; 场景：Github中代码更新后自动推送到服务器并部署\n\u0026amp;#x1f527; 工具：Webhook​\n1. Github配置Webhook\r\u0026amp;#x1f4cd;例如我在anbydemara.github.io该仓库中存储了我的静态博客网站，我希望当我push到该仓库时，Github自动通知我的服务器并执行自定义指令。\n\u0026amp;#x31;\u0026amp;#xfe0f;\u0026amp;#x20e3; ​进入Github仓库，Settings-\u0026amp;gt;Webhooks-\u0026amp;gt;Add webhook\n\u0026amp;#x32;\u0026amp;#xfe0f;\u0026amp;#x20e3; 填写配置信息\nPayLoad URL：http://your_servier_ip:port/path/{id}，其中port:9000，path:hooks都是默认值，我们保存不变。修改修改为自己的ip地址，并且为该Payload自定义一个id\nContent type：选择application/json格式\nSecret：设置自己的Secret token用于验证，可以使用一个随机字符串\nwebhook触发条件：Just push event表示push代码到仓库时触发，可以自定义其他事件\n其他保持默认，最后Update webhook：\n2. 服务器创建hook\r\u0026amp;#x1f4cd;我们使用webhook工具：\nwebhook is a lightweight configurable tool written in Go, that allows you to easily create HTTP endpoints (hooks) on your server, which you can use to execute configured commands. You can also pass data from the HTTP request (such as headers, payload or query variables) to your commands. webhook also allows you to specify rules which have to be satisfied in order for the hook to be triggered.\n2.1 …","date": "2025-07-23 10:00:00",
    "updated": "2025-07-23 10:00:00"
  }, 
  {
    "objectID": "17ef4c511925b169183667610ab3598d176237f7",
    "permalink": "/post/picgo-typora/",
    "title": "PicGo实现Typora插入图片上传服务","content": "现在已经有非常多的快速搭建博客站的工具，例如JeckII、Hexo、Hugo等，它们都具有非常优秀的使用体验，并且可以通过GitHub、CloudFlare等工具进行免费部署。利用它们成功搭建出自己的博客站后，往往使用Markdown进行博客内容撰写。在撰写过程中，我们会发现处理图片时会面临一些窘境：\n需要将图片放到特定资源文件夹（进行上传），操作不方便 图片过多后占用空间 图片太大时加载速度慢等 我们可以采用将图片资源存放到图床的方案解决图片存储、路径问题。此外，在写作过程中通过安装PicGo工具+压缩等插件简化撰写过程，接下来跟我一起让写博客变得更加优雅吧！\n1. 安装\rPicGo: 一个用于快速上传图片并获取图片 URL 链接的工具，官方文档：PicGo有详细的使用教程。\n下载：PicGo-release，PicGo提供众多beta版本，若希望体验新功能可安装最新beta版本。推荐安装正式版本。下载对应系统安装包进行安装，这里以windows系统为例，下载2.3.1版本安装程序： 运行安装程序进行安装，安装成功后开始使用PicGo： 2. 配置图床\rPicGo 本体支持如下图床：\n七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 \u0026amp;amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 本文使用七牛云对象存储。\n2.1 七牛云对象存储申请\r进入七牛云 | 一站式中立音视频云 + AI，完成账号设置（注册、登录、认证等）。 完成后进入控制台（入口在网页右上角），选择新建存储空间： 在新建存储空间面板中填写信息： 存储空间名称：自定义 存储区域：如果你拥有已备案的域名或者仅做测试使用，选择国内区域。如果你的域名无法备案，可选择海外区域（不需要备案，但访问可能需要梯子） 访问控制：公开（更方便） ​ 填写完成后点击确认。\n绑定域名\n存储空间创建后，会分配一个测试域名，可以直接使用，但是会被回收，因此不推荐实际使用。\n如果没有域名，可以注册免费域名，详见：。\n拥有一个域名后，进入新建的存储空间进行域名管理：\n因为CDN加速域名需要进行域名所有权认证，所以我这里选择自定义源站域名，点击绑定域名后，填写：\n从绑定的域名列表中，复制CNAME …","date": "2025-07-22 12:00:00",
    "updated": "2025-07-22 12:00:00"
  }, 
  {
    "objectID": "48d23cb87473a3bee8bbe59278bf79919d7348c5",
    "permalink": "/post/causehsi-readme/",
    "title": "CauseHSI项目说明","content": "\r1 简介\rCauseHSI项目为论文CauseHSI: Cross-scene Hyperspectral image classifaction via Causal Disentanglement提供代码实现。CauseHSI用于高光谱图像跨场景分类任务，其架构图如下：\nCauseHSI主要分为两个部分：生成模块Generation Module(CGM)和因果解耦模块Causal Disentanglement Module(CDM)\n2. 使用\r2.1 准备\r2.1.1 Requirements\rpip intsall -r requirements.txt 2.1.2 数据集存储结构\r#### 数据集目录结构 ├── data │ └── datasets │ ├── Houston │ ├── Pavia │ └── HyRANK └── ... 2.1.3 Pre-Augmented\r在我们的方法中，需要对源域数据进行一次DCT变换和IDCT变换，我们的方法是基于Patch的高光谱图像分类任务，如果对每一个Patch进行变换降低了模型计算速度。因此，我们推荐您直接对原始数据（一张完整的高光谱图像）进行变换\npython scg_aug.py 2.2 Train\rHouston: python train-gan.py --data_path Houston/ --source_domain Houston13 --target_domain Houston18 \\ --training_sample_ratio 0.8 --flip_augmentation --radiation_augmentation Pavia: python train-gan.py --data_path Pavia/ --source_domain PaviaU --target_domain PaviaC \\ --training_sample_ratio 0.5 HyRANK: python train-gan.py --data_path HyRANK/ --source_domain Dioni --target_domain Loukia \\ --training_sample_ratio 0.8 2.3 Visualization\r2.4 Loss\r2.4.1 Causal-inspired Disentanglement Loss\r2.1. independence loss\n2.2.1 reconstruction loss\n2.2.2 causal loss for disentanglement\n2.3. consistency loss\n2.4.2 Domain Generation Loss\rbalance loss for Generator\n2.4.3 Basic Loss\rSD classification loss\nED classification loss\n3. Acknowledgments\r我们在此衷心感谢以下作者提供的开源代码：\n我们的论文在数据处理、空间随机化和光谱随机化采用了xxx所提供的代码实现，并且该论文也是我们做该研究的启发 数据集来自于 https://github.com/YuxiangZhang-BIT/Data-CSHSI 整理的Houston、Pavia和HyRANK 特征提取模块我们采用了CVSS的部分结构 对于图像的采用DCT变换是常用手段，我们对于该部分的处理借鉴了自然图像领域的处理，主要是来自于论文xxx HSIC独立性评判准则是一个经典方法，我们采用了xxx所提供的代码实现，同时简单沿用了早期分支的思想。该论文也启发我们尝试使用解耦作为解决高光谱跨场景分类任务的解决方案，而不是继续延续现在最常用的对比学习和对比对抗学习 ","date": "2025-07-21 22:57:57",
    "updated": "2025-07-22 13:30:57"
  }, 
  {
    "objectID": "3e52215bd0708a59086c8b84955f7c64a2a9c2e5",
    "permalink": "/post/docker-run/",
    "title": "Docker常用容器部署","content": " nginx\ndocker run -d \\ --name nginx \\ -p 80:80 -p 443:443 \\ -v ~/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v ~/docker/nginx/conf/default.conf:/etc/nginx/conf.d/default.conf \\ -v ~/docker/nginx/html:/usr/share/nginx/html \\ -v ~/docker/nginx/ssl:/etc/nginx/ssl \\ nginx # 复制初始化后的nginx.conf、default.conf # 必要时指定network mysql\ndocker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=root \\ -v /root/mysql/data:/var/lib/mysql \\ -v /root/mysql/conf:/etc/mysql/conf.d \\ --network apps-net\\ mysql redis\ndocker run -d \\ --name redis \\ -p 6379:6379 \\ -v /usr/local/src/docker/redis/data:/data \\ -v /usr/local/src/docker/redis/conf/redis.conf:/etc/redis/redis.conf \\ --network apps-net \\ redis-server /etc/redis/redis.conf redis # 配置文件/etc/redis/redis.conf ","date": "2025-07-20 12:00:00",
    "updated": "2025-07-20 12:00:00"
  }]